// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sessions.sql

package db

import (
	"context"
	"database/sql"
)

const endSession = `-- name: EndSession :one
UPDATE sessions 
SET end_time = ?
WHERE task_id = ?
RETURNING id, start_time, end_time, task_id
`

type EndSessionParams struct {
	EndTime sql.NullString `json:"end_time"`
	TaskID  int64          `json:"task_id"`
}

func (q *Queries) EndSession(ctx context.Context, arg EndSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, endSession, arg.EndTime, arg.TaskID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.TaskID,
	)
	return i, err
}

const getDailyTaskDurations = `-- name: GetDailyTaskDurations :many
SELECT task_id, SUM(duration_seconds) as total_seconds
FROM (
    -- the session that spans two days will be stored in db as a single session, but will be divided between 2 days inside the app
    -- also this is for anyday, not just today. will make wrappers for this query inside app instead.
    -- '?' arg is the queried date
    -- 1. sessions spanning single day, day x
    SELECT s.task_id, 
    strftime('%s', s.end_time) - strftime('%s', s.start_time) AS duration_seconds
    FROM sessions AS s
    WHERE s.start_time >= ?1 
    AND s.end_time < strftime('%s', ?1, '+1 day', 'start of day')
    UNION ALL
    -- 2. sessions spanning two days, started on day x (not accounting for sessions spanning more than 2 days)
    SELECT s.task_id, 
    strftime('%s', ?1, '+1 day', 'start of day') - strftime('%s', start_time) AS duration_seconds
    FROM sessions AS s
    WHERE date(s.start_time) = date(?1) 
    AND date(s.end_time) = date(?1, '+1 day')
    OR s.end_time IS NULL
    UNION ALL

    --3. sessions spanning two days, ending on day x
    SELECT s.task_id, 
    strftime('%s', s.end_time) - strftime('%s', ?1, 'start of day') AS duration_seconds
    FROM sessions AS s
    WHERE date(s.start_time) = date(?1, '-1 day') 
    AND date(s.end_time) = date(?1)
) AS daily_sessions
GROUP BY task_id
`

type GetDailyTaskDurationsRow struct {
	TaskID       int64           `json:"task_id"`
	TotalSeconds sql.NullFloat64 `json:"total_seconds"`
}

func (q *Queries) GetDailyTaskDurations(ctx context.Context, queryDate string) ([]GetDailyTaskDurationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDailyTaskDurations, queryDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyTaskDurationsRow
	for rows.Next() {
		var i GetDailyTaskDurationsRow
		if err := rows.Scan(&i.TaskID, &i.TotalSeconds); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startSession = `-- name: StartSession :one
INSERT INTO sessions (start_time, task_id)
VALUES (?, ?)
RETURNING id, start_time, end_time, task_id
`

type StartSessionParams struct {
	StartTime string `json:"start_time"`
	TaskID    int64  `json:"task_id"`
}

func (q *Queries) StartSession(ctx context.Context, arg StartSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, startSession, arg.StartTime, arg.TaskID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.TaskID,
	)
	return i, err
}
